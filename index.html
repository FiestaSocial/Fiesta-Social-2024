<!DOCTYPE html>
<html lang="en">
<cabeza>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Partido Social 2024</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :raíz {
            --color-primario: #0b66ff;
            --color-primary-dark: #084dcc;
            --color-secundario: #f39c12;
            --color de fondo: #0f172a;
            --color de superficie: #ffffff;
            --color-muted: #64748b;
            --border-color: #e2e8f0;
            --color-success: #22c55e;
            --color-danger: #ef4444;
            --shadow-lg: 0 24px 60px rgba(15, 23, 42, 0.25);
            --shadow-md: 0 14px 35px rgba(15, 23, 42, 0.18);
            --radius-lg: 28px;
            --radius-md: 18px;
            --radius-sm: 12px;
        }

        * {
            tamaño de caja: caja con borde;
        }

        cuerpo {
            margen: 0;
            altura mínima: 100vh;
            font-family: 'Poppins', 'Segoe UI', sans-serif;
            fondo: degradado radial (círculo en la parte superior izquierda, rgba(59, 130, 246, 0.45), transparente 55%),
                        gradiente radial (círculo en la parte inferior derecha, rgba(234, 179, 8, 0.35), transparente 55%),
                        gradiente-lineal(135deg, #0f172a, #1e293b 45%, #0f172a 90%);
            color: #0f172a;
            relleno: 40px 16px 60px;
            pantalla: flexible;
            justificar-contenido: centro;
        }

        principal {
            ancho: 100%;
            ancho máximo: 1100 píxeles;
        }

        h1, h2, h3 {
            color: #0f172a;
            margen: 0 0 12px 0;
        }

        pag {
            margen: 0 0 16px;
            color: var(--color-muted);
            altura de línea: 1,6;
        }

        .contenedor {
            fondo: var(--color-surface);
            radio-borde: var(--radius-lg);
            relleno: 32px 32px 40px;
            box-shadow: var(--shadow-lg);
            pantalla: ninguna;
            margen inferior: 32px;
            posición: relativa;
            desbordamiento: oculto;
        }

        .contenedor::después {
            contenido: "";
            posición: absoluta;
            recuadro: 0;
            fondo: degradado radial (círculo en la parte superior derecha, rgba(11, 102, 255, 0.08), transparente 55%);
            eventos de puntero: ninguno;
        }

        .contenedor.activo {
            pantalla: bloque;
            animación: fadeIn 0.45s ease;
        }

        @keyframes fadeIn {
            de {
                opacidad: 0;
                transformar: traslaciónY(10px);
            }
            a {
                opacidad: 1;
                transformar: traslaciónY(0);
            }
        }

        .hero-card {
            pantalla: cuadrícula;
            espacio: 32px;
            columnas-plantilla-cuadrícula: repetir(ajuste automático, minmax(280px, 1fr));
            alinear elementos: centro;
        }

        .hero-card__content {
            posición: relativa;
            índice z: 1;
        }

        .hero-card__eyebrow {
            pantalla: inline-flex;
            alinear elementos: centro;
            espacio: 8px;
            relleno: 6px 14px;
            radio de borde: 999px;
            fondo: rgba(11, 102, 255, 0.1);
            color: var(--color-primary);
            grosor de la fuente: 600;
            transformación de texto: mayúsculas;
            espaciado entre letras: 0,08em;
            tamaño de fuente: 12px;
        }

        .hero-card__title {
            tamaño de fuente: clamp(32px, 5vw, 48px);
            grosor de la fuente: 700;
            margen inferior: 16px;
        }

        .hero-card__description {
            tamaño de fuente: 16px;
            color: rgba(15, 23, 42, 0.8);
            margen inferior: 24px;
        }

        .hero-card__actions {
            pantalla: flexible;
            flex-wrap: envolver;
            espacio: 12px;
        }

        .hero-card__media {
            margen: 0;
            posición: relativa;
            radio-borde: var(--radius-md);
            desbordamiento: oculto;
            box-shadow: var(--shadow-md);
        }

        .hero-card__media::after {
            contenido: "";
            posición: absoluta;
            recuadro: 0;
            fondo: gradiente-lineal(135deg, rgba(15, 23, 42, 0.15), rgba(15, 23, 42, 0.05));
        }

        .hero-card__media img {
            ancho: 100%;
            altura: 100%;
            ajuste del objeto: cubierta;
            pantalla: bloque;
        }

        .section-description {
            tamaño de fuente: 15px;
            color: rgba(15, 23, 42, 0.7);
            margen inferior: 24px;
        }

        .form-grid {
            pantalla: cuadrícula;
            columnas-plantilla-de-cuadrícula: repetir(ajuste automático, minmax(240px, 1fr));
            espacio: 20px;
        }

        .form-field {
            pantalla: flexible;
            dirección flexible: columna;
            espacio: 8px;
        }

        etiqueta {
            grosor de la fuente: 600;
            color: rgba(15, 23, 42, 0.85);
            tamaño de fuente: 14px;
        }

        entrada, seleccionar {
            relleno: 12px 14px;
            radio-borde: var(--radius-sm);
            borde: 1px solid var(--color-border);
            tamaño de fuente: 15px;
            transición: borde con suavizado de 0,2 segundos, sombra de caja con suavizado de 0,2 segundos;
            fondo: #f8fafc;
        }

        entrada:enfoque, selección:enfoque {
            esquema: ninguno;
            color de borde: rgba(11, 102, 255, 0.8);
            box-shadow: 0 0 0 4px rgba(11, 102, 255, 0.12);
        }

        entrada: no válida, selección: no válida {
            color de borde: rgba(239, 68, 68, 0.6);
        }

        .botón {
            pantalla: inline-flex;
            alinear elementos: centro;
            justificar-contenido: centro;
            espacio: 8px;
            borde: ninguno;
            radio de borde: 999px;
            relleno: 12px 24px;
            tamaño de fuente: 15px;
            grosor de la fuente: 600;
            cursor: puntero;
            transición: transformación 0.2s suavizado, sombra de caja 0.2s suavizado;
            decoración de texto: ninguna;
        }

        .botón--primario {
            fondo: var(--color-primario);
            color: #fff;
            box-shadow: 0 16px 30px rgba(11, 102, 255, 0.25);
        }

        .button--primary:hover {
            fondo: var(--color-primary-dark);
            transformar: traslaciónY(-1px);
        }

        .botón--fantasma {
            fondo: rgba(15, 23, 42, 0.04);
            color: var(--color-primary);
        }

        .button--ghost:hover {
            fondo: rgba(15, 23, 42, 0.1);
        }

        .botones-de-navegación {
            margen superior: 32px;
            pantalla: flexible;
            justificar-contenido: flex-end;
            espacio: 16px;
        }

        .salon-wrapper {
            pantalla: cuadrícula;
            columnas de plantilla de cuadrícula: 260px 1fr;
            espacio: 28px;
            margen inferior: 32px;
            alinear elementos: inicio;
        }

        .salon-summary {
            fondo: rgba(248, 250, 252, 0.9);
            radio-borde: var(--radius-md);
            relleno: 20px;
            box-shadow: 0 8px 24px rgba(15, 23, 42, 0.08);
            posición: fija;
            parte superior: 32px;
        }

        .salon-summary h3 {
            tamaño de fuente: 18px;
            margen inferior: 12px;
        }

        .salon-summary p {
            margen inferior: 12px;
            color: rgba(15, 23, 42, 0.75);
        }

        .leyenda {
            pantalla: flexible;
            dirección flexible: columna;
            espacio: 8px;
            margen superior: 12px;
        }

        .leyenda span {
            pantalla: inline-flex;
            alinear elementos: centro;
            espacio: 8px;
            tamaño de fuente: 14px;
            color: rgba(15, 23, 42, 0.8);
        }

        .leyenda-muestra {
            ancho: 16px;
            altura: 16px;
            borde-radio: 4px;
            mostrar: bloque en línea;
        }

        .legend-swatch--available {
            fondo: var(--color-primario);
        }

        .legend-swatch--full {
            fondo: var(--color-peligro);
        }

        .legend-swatch--selected {
            fondo: var(--color-secundario);
        }

        .mapa-de-salones {
            posición: relativa;
            ancho: 100%;
            Relación de aspecto: 16 / 9;
            fondo: gradiente-lineal(135deg, rgba(226, 232, 240, 0.8), rgba(203, 213, 225, 0.6));
            radio-borde: var(--radius-md);
            box-shadow: 0 20px 40px rgba(15, 23, 42, 0.18);
            desbordamiento: oculto;
        }

        .map-zone {
            posición: absoluta;
            izquierda: calc(var(--zone-x, 50) * 1%);
            arriba: calc(var(--zone-y, 50) * 1%);
            transformar: trasladar(var(--zone-tx, -50%), var(--zone-ty, -50%)) rotar(var(--zone-rotate, 0deg));
            transform-origin: var(--zone-origin, center);
            relleno: 6px 16px;
            radio de borde: 999px;
            tamaño de fuente: 12px;
            grosor de la fuente: 600;
            transformación de texto: mayúsculas;
            espaciado entre letras: 0,08em;
            color: #fff;
            fondo: rgba(15, 23, 42, 0.7);
            eventos de puntero: ninguno;
            índice z: 1;
            espacio en blanco: ahora
        }

        .map-zone--dance {
            fondo: rgba(34, 197, 94, 0.85);
        }

        .map-zone--stage {
            --zone-tx: 0%;
            --tipo-zona: -50%;
            --rotación de zona: -90 grados;
            --origen de zona: centro izquierdo;
            fondo: rgba(59, 130, 246, 0.9);
        }

        .map-zone--entrance {
            --tipo-zona: 0%;
            fondo: rgba(59, 130, 246, 0.9);
        }

        .map-zone--dj {
            --tipo-zona: -100%;
            fondo: rgba(59, 130, 246, 0.9);
        }

        .map-zone--dessert {
            ancho: 24px;
            alineación del texto: centro;
            modo de escritura: vertical-rl;
            espaciado entre letras: 0,2 em;
            relleno: 12px 6px;
            fondo: rgba(59, 130, 246, 0.9);
        }

        .map-zone--dessert-left {
            --zona-tx: -50%;
        }

        .map-zone--dessert-right {
            --zona-tx: -50%;
        }

        .mesa {
            posición: absoluta;
            ancho: 52 píxeles;
            altura: 52 píxeles;
            borde-radio: 16px;
            fondo: var(--color-primario);
            color: #fff;
            grosor de la fuente: 600;
            pantalla: flexible;
            alinear elementos: centro;
            justificar-contenido: centro;
            box-shadow: 0 10px 22px rgba(11, 102, 255, 0.22);
            transformar: traslación(-50%, -50%);
            borde: ninguno;
            cursor: puntero;
            transición: transformación 0.2s suavizado, sombra de caja 0.2s suavizado, fondo 0.2s suavizado;
            índice z: 2;
        }

        .table:hover,
        .table:focus {
            transformar: traslación(-50%, -50%) escala(1.05);
            box-shadow: 0 14px 30px rgba(11, 102, 255, 0.3);
            esquema: ninguno;
        }

        .tabla.completa {
            fondo: var(--color-peligro);
            box-shadow: 0 12px 26px rgba(239, 68, 68, 0.3);
        }

        .tabla.seleccionada {
            fondo: var(--color-secundario);
            box-shadow: 0 14px 32px rgba(243, 156, 18, 0.35);
        }

        .detalles-tabla {
            pantalla: cuadrícula;
            columnas-plantilla-cuadrícula: repetir(ajuste automático, minmax(260px, 1fr));
            espacio: 24px;
            margen inferior: 24px;
        }

        .contenedor-tabla {
            posición: relativa;
            ancho: 100%;
            relleno superior: 100%;
            radio-borde: var(--radius-md);
            fondo: rgba(248, 250, 252, 0.9);
            box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.08);
            pantalla: ninguna;
        }

        #contenedor de asientos {
            posición: absoluta;
            recuadro: 0;
        }

        .mesa {
            posición: absoluta;
            parte superior: 50%;
            izquierda: 50%;
            transformar: traslación(-50%, -50%);
            ancho: 120 píxeles;
            altura: 120 píxeles;
            radio de borde: 50%;
            fondo: var(--color-primario);
            color: #fff;
            tamaño de fuente: 18px;
            grosor de la fuente: 600;
            pantalla: flexible;
            alinear elementos: centro;
            justificar-contenido: centro;
            box-shadow: 0 12px 28px rgba(11, 102, 255, 0.25);
        }

        #contenedor de asientos .asiento {
            ancho: 42px;
            altura: 42px;
            borde-radio: 12px;
            fondo: var(--color-success);
            pantalla: flexible;
            alinear elementos: centro;
            justificar-contenido: centro;
            color: #fff;
            grosor de la fuente: 600;
            transición: transformación 0.2s suavizado, fondo 0.2s suavizado;
        }

        #seatsContainer .seat.occupied {
            fondo: var(--color-peligro);
        }

        #listadeinvitados {
            altura mínima: 180px;
            fondo: rgba(248, 250, 252, 0.85);
            radio-borde: var(--radius-md);
            relleno: 20px;
            box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.08);
            tamaño de fuente: 14px;
            pantalla: cuadrícula;
            espacio: 6px;
        }

        #lista de invitados fuerte {
            color: rgba(15, 23, 42, 0.9);
        }

        #formularioacompañado {
            pantalla: cuadrícula;
            espacio: 16px;
        }

        #formularioacompañado h3 {
            margen superior: 24px;
        }

        #cantidad de acompañantes {
            transición: opacidad 0.2s suavidad;
        }

        .tooltip {
            posición: absoluta;
            fondo: rgba(15, 23, 42, 0.88);
            color: #fff;
            relleno: 10px 14px;
            radio-borde: var(--radius-sm);
            tamaño de fuente: 13px;
            pantalla: ninguna;
            ancho máximo: 280px;
            altura de línea: 1.4;
            Índice z: 50;
            eventos de puntero: ninguno;
        }

        .modal-overlay {
            posición: fija;
            recuadro: 0;
            fondo: rgba(15, 23, 42, 0.65);
            pantalla: ninguna;
            alinear elementos: centro;
            justificar-contenido: centro;
            relleno: 24px;
            índice z: 100;
        }

        .modal-overlay.active {
            pantalla: flexible;
        }

        .modal-content {
            fondo: #fff;
            radio-borde: var(--radius-lg);
            relleno: 32px;
            ancho máximo: 420 píxeles;
            alineación del texto: centro;
            box-shadow: var(--shadow-lg);
        }

        .modal-content h2 {
            margen inferior: 12px;
        }

        .modal-content p {
            color: rgba(15, 23, 42, 0.75);
            margen inferior: 24px;
        }

        @media (max-width: 900px) {
            cuerpo {
                relleno: 24px 12px 48px;
            }

            .salon-wrapper {
                columnas de plantilla de cuadrícula: 1fr;
            }

            .salon-summary {
                posición: relativa;
                arriba: automático;
            }
        }

        @media (max-width: 600px) {
            .hero-card {
                columnas de plantilla de cuadrícula: 1fr;
            }

            .botones-de-navegación {
                flex-direction: column-reverse;
                alinear elementos: estirar;
            }

            .botones-de-navegación .botón {
                ancho: 100%;
            }
        }
    </style>
</head>
<cuerpo>
    <principal>
        <section id="screen1" class="container active">
            <div class="hero-card">
                <div class="hero-card__content">
                    <span class="hero-card__eyebrow" id="siteSubtitle">Registro oficial de invitados</span>
                    <h1 class="hero-card__title" id="siteTitleHeading">Fiesta Social 2024</h1>
                    <p class="hero-card__description" id="siteDescription">Confirma tu asistencia, elige tu menú y selecciona tu mesa favorita dentro del salón principal.</p>
                    <div class="hero-card__actions">
                        <button class="button button--primary" onclick="nextScreen(2)">Iniciar registro</button>
                        <a class="button button--ghost" href="admin.html">Administración</a>
                    </div>
                </div>
                <figure class="hero-card__media">
                    <img id="heroImage" src="Welcome Image.png" alt="Celebración en el salón principal">
                </figura>
            </div>
        </section>

        <section id="screen2" class="container">
            <h2>Datos personales</h2>
            <p class="section-description">Completa tus datos para asegurar tu lugar en la celebración.</p>
            <form id="guestForm" class="form-grid">
                <div class="form-field">
                    <label for="mail">Correo</label>
                    <input type="email" id="email" name="email" required>
                </div>
                <div class="form-field">
                    <label for="grade">Calificación</label>
                    <select id="grade" name="grade" required>
                        <option value="" selected>Seleccionar</option>
                        <option value="Cnel.">Cnel.</option>
                        <option value="Teniente Comandante">Teniente Comandante</option>
                        <option value="Mayo.">Mayo.</option>
                        <option value="Cap.">Cap.</option>
                        <option value="Tte. 1°">Tte. 1°</option>
                        <option value="Tte. 2°">Tte. 2°</option>
                        <option value="Alf.">Alf.</option>
                    </select>
                </div>
                <div class="form-field">
                    <label for="escalafon">Escalafon</label>
                    <select id="escalafon" name="escalafon" required>
                        <option value="" selected>Seleccionar</option>
                        <opción valor="Av.">(Av.)</option>
                        <option value="Nav.">(Nav.)</option>
                        <option value="Esp.">(Esp)</option>
                        <option value="TP">(TP)</option>
                    </select>
                </div>
                <div class="form-field">
                    <label for="name">Nombre</label>
                    <input type="text" id="name" name="name" required>
                </div>
                <div class="form-field">
                    <label for="surname">Apellido</label>
                    <input type="text" id="surname" name="surname" required>
                </div>
                <div class="form-field">
                    <label for="cedula">Documento de identidad (formato 0.000.000-0)</label>
                    <input type="text" id="cedula" name="cedula" required pattern="^\d\.\d{3}\.\d{3}-\d$" title="El formato debe ser 0.000.000-0. Ejemplo: 4.646.789-2">
                </div>
                <div class="form-field">
                    <label for="companion">¿Asistes acompañado/a?</label>
                    <select id="companion" name="companion" required onchange="togglecompanion()">
                        <option value="" selected>Seleccionar</option>
                        <option value="no">No</option>
                        <option value="yes">Sí</option>
                    </select>
                </div>
                <div class="form-field" id="accompananteQuantity" style="display:none;">
                    <label for="quantidadAcompanantes">¿Cuántos acompañantes?</label>
                    <select id="quantidadAcompanantes" name="quantidadAcompanantes">
                        <option value="" selected>Seleccionar</option>
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                    </select>
                </div>
                <div class="form-field">
                    <label for="menu">Menú</label>
                    <select id="menu" name="menu" required>
                        <option value="" selected>Seleccionar</option>
                        <option value="normal">Normal</option>
                        <option value="vegetarian">Vegetariano</option>
                        <option value="vegan">Vegano</option>
                        <option value="celiac">Celiaco</option>
                    </select>
                </div>
                <input type="hidden" id="table" name="table">
            </form>
            <div class="navigation-buttons">
                <button class="button button--ghost" onclick="prevScreen(1)">Anterior</button>
                <button class="button button--primary" onclick="nextScreen()">Siguiente</button>
            </div>
        </section>

        <section id="screen3" class="container">
            <h2>Información de los acompañantes</h2>
            <p class="section-description">Añade los datos de cada invitado adicional.</p>
            <form id="companantesForm"></form>
            <div class="navigation-buttons">
                <button class="button button--ghost" onclick="prevScreen(2)">Anterior</button>
                <button class="button button--primary" onclick="nextScreen(4)">Siguiente</button>
            </div>
        </section>

        <section id="screen4" class="container">
            <h2>Selecciona tu mesa</h2>
            <p class="section-description">Explora el plano interactivo del salón y elige la mesa que prefieras. Haz clic para revisar la disponibilidad y los invitados registrados.</p>
            <div class="salon-wrapper">
                <aside class="salon-summary">
                    <h3>Resumen del salón</h3>
                    <p><strong>Mesas disponibles:</strong> <span id="totalMesasCounter">--</span></p>
                    <p><strong>Capacidad total:</strong> <span id="capacidadTotalCounter">--</span> invitados</p>
                    <p><strong>Mesa seleccionada:</strong> <span id="mesaSeleccionadaLabel">Sin seleccionar</span></p>
                    <div class="legend">
                        <span><span class="legend-swatch legend-swatch--available"></span>Disponible</span>
                        <span><span class="legend-swatch legend-swatch--full"></span>Completa</span>
                        <span><span class="legend-swatch legend-swatch--selected"></span>Seleccionada</span>
                    </div>
                </aside>
                <div class="salon-map" id="salonMap"></div>
            </div>
            <div class="table-details">
                <div class="table-container">
                    <div class="table" id="mesaText">Mesa</div>
                    <div id="seatsContainer"></div>
                </div>
                <div>
                    <h3>Invitados registrados en esta mesa</h3>
                    <div id="guestList">Selecciona una mesa para ver los invitados.</div>
                </div>
            </div>
            <div class="navigation-buttons">
                <button class="button button--ghost" onclick="prevScreen(3)">Anterior</button>
                <button id="submitReservationBtn" class="button button--primary" onclick="submitForm()">Enviar</button>
            </div>
        </section>
    </main>

    <div id="confirmationModal" class="modal-overlay">
        <div class="modal-content">
            <h2>Registro completo</h2>
            <p>Su reserva se ha guardado en <strong id="mesaConfirmada"></strong>. Si desea realizar algún cambio, contacte con la Secretaría de Contabilidad del BA III.</p>
            <button class="button button--primary" onclick="finalizeRegister()">Finalizar</button>
        </div>
    </div>

    <div id="tooltip" class="tooltip"></div>

    <script>
        Sea pantallaActual = 1;
        sea ​​guestsData = {};
        sea ​​dataFetchInterval;
        sea ​​siteConfig = nulo;

        window.dumpReservationDebug = function dumpReservationDebug() {
            const log = window.__reservationDebug || [];
            const summary = log.map(entry => ({
                id: entry.id,
                Enviado en: entrada.enviado en,
                estado: entry.status || 'pendiente',
                modo de éxito: entrada.modo de éxito || 'n/a',
                intentos: Array.isArray(entry.attempts) ? entry.attempts.length : 0,
                getAttempts: Array.isArray(entry.getAttempts) ? entry.getAttempts.length : 0,
                estadoDeVerificación: entry.verification?.status || 'n/a',
                punto final: punto final de entrada
            }));
            if (summary.length) {
                console.table(summary);
            } demás {
                console.info('[Reservas] No hay envíos registrados en memoria.');
            }
            devolver registro;
        };

        const PUNTO_FINAL_DE_RESERVA_PREDETERMINADO = 'https://script.google.com/macros/s/AKfycbwo8xOJg-44KB3G07TXshbCP7sYtYwQaWxe9U9g4RMvUWNlFobqP-nCIcHeWjvGC1wZCQ/exec';
        const DEFAULT_GUESTS_SHEET_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRMTgpYpR5TVrCZMfOFzMUdXyW4wtu27U6VyN4w-zUwqki6m_Ts2icDBpL1gSyoxBpie6Xup_BxuR1g/pub?output=csv';
        constante INTERVALO_DE_ENCUESTA_DE_SUSCRIPCIÓN = 3000;
        constante SUBMISSION_MAX_WAIT = 20000;
        const ACCOMPANANTE_NAME_PREFIX = 'nombre del acompañante';
        const EMAIL_KEYS = ['email', 'email', 'email', 'email', 'email'];
        const CEDULA_KEYS = ['certificado', 'certificado', 'documento', 'documento de identidad', 'documento de identidad', 'ci'];
        const NAME_KEYS = ['name', 'names'];
        const LAST_NAME_KEYS = ['apellido', 'apellidos'];

        sea ​​reservationScriptUrl = DEFAULT_RESERVATION_ENDPOINT;
        sea ​​guestsSheetCsvUrl = DEFAULT_GUESTS_SHEET_CSV_URL;

        const ZONAS_PREDETERMINADAS = [
            { id: 'dance', label: 'Pista de baile', className: 'map-zone--dance', position: { x: 50, y: 45 } },
            { id: 'stage', label: 'Estado Mayor', className: 'map-zone--stage', position: { x: 6, y: 50 } },
            { id: 'entrance', label: 'Entrada / Piscina', className: 'map-zone--entrance', position: { x: 50, y: 6 } },
            { id: 'dj', etiqueta: 'DJ', nombreClase: 'map-zone--dj', posición: { x: 50, y: 94 } },
            { id: 'dessertLeft', label: 'Postres', className: 'map-zone--dessert map-zone--dessert-left', position: { x: 92, y: 28 } },
            { id: 'dessertRight', label: 'Postres', className: 'map-zone--dessert map-zone--dessert-right', position: { x: 92, y: 72 } }
        ];

        función normalizarCadena(valor) {
            Si (valor === indefinido || valor === nulo) devolver '';
            valor de retorno
                .toString()
                .normalizar('NFD')
                .reemplazar(/[\u0300-\u036f]/g, '')
                .toLowerCase()
                .recortar();
        }

        función appendCacheBuster(url) {
            Si (!url) devolver '';
            const separador = url.includes('?') ? '&' : '?';
            devolver `${url}${separator}_=${Date.now()}`;
        }

        función obtenerValorDeInvitado(invitado, clavesCandidatas) {
            if (!guest || typeof guest !== 'object') return '';
            const candidatos normalizados = clavesCandidatos.map(cadenaNormalizada);
            for (const key of Object.keys(guest)) {
                const clave normalizada = normalizarCadena(clave);
                const índiceCandidato = candidatosNormalizados.indexOf(claveNormalizada);
                si (candidateIndex !== -1) {
                    const valor = invitado[clave];
                    if (value !== undefined && value !== null && value !== '') {
                        valor de retorno;
                    }
                }
            }
            devolver '';
        }

        función extraerNombresCompañeros(invitado) {
            if (!guest || typeof guest !== 'object') return [];
            Devuelve Object.keys(invitado)
                .filter(key => normalizeString(key).startsWith(COMPANANT_NAME_PREFIX))
                .map(clave => invitado[clave])
                .filter(value => value !== undefined && value !== null && value !== '');
        }

        función contarAsientosParaInvitados(invitado) {
            const compañeros = extraerNombresCompañeros(invitado);
            Devuelve 1 + compañeros.longitud;
        }

        función obtenerNombreCompletoInvitado(invitado) {
            const nombre = obtenerValorDeInvitado(invitado, NAME_KEYS);
            const apellido = obtenerValorDeInvitado(invitado, CLAVES_AÑO);
            return [nombre, apellido].filter(Boolean).join(' ').trim();
        }

        función obtenerCorreoElectrónicoInvitado(invitado) {
            devolver getValueFromGuest(guest, EMAIL_KEYS);
        }

        función obtenerCédulaDeInvitado(invitado) {
            devolver getValueFromGuest(guest, CEDULA_KEYS);
        }

        función guestMatchesFingerprint(invitado, huella digital) {
            if (!guest || !fingerprint) return false;
            const cédulaInvitado = normalizarCadena(obtenerCédulaInvitado(invitado));
            if (fingerprint.normalizedCedula && cedulaGuest && cedulaGuest === fingerprint.normalizedCedula) {
                devuelve verdadero;
            }
            const correoInvitado = normalizarCadena(obtenerCorreoInvitado(invitado));
            if (fingerprint.normalizedCorreo && correoGuest && correoGuest === fingerprint.normalizedCorreo) {
                devuelve verdadero;
            }
            const nombreInvitado = normalizarCadena(obtenerNombreCompletoInvitado(invitado));
            if (fingerprint.normalizedFullName && Guestname && Guestname === fingerprint.normalizedFullName) {
                devuelve verdadero;
            }
            devolver falso;
        }

        función crearHuellaDeReserva(datos) {
            devolver {
                tabla: data.table,
                cédula normalizada: normalizarCadena(datos.cédula),
                normalizadoCorreo: normalizeString(datos.correo),
                nombreCompletoNormalizado: normalizarCadena(`${data.name || ''} ${data.surname || ''}`),
                rawSchedule: data.schedule,
                rawMail: data.mail,
                rawFullName: `${data.name || ''} ${date.surname || ''}`.trim()
            };
        }

        función retardo(ms) {
            devolver nueva Promesa(resolver => setTimeout(resolver, ms));
        }

        async function confirmReservationPersisted(fingerprint, baselineGuests, debugEntry = null) {
            const baselineMatches = (baselineGuests || []).filter(guest => guestMatchesFingerprint(guest, fingerprint));
            const baselineCounts = buildFingerprintCountMap(baselineMatches);
            const verificationLabel = '[Reservas] Verificación de persistencia';
            const groupSupported = typeof console.groupCollapsed === 'function' && typeof console.groupEnd === 'function';
            Sea númeroIntento = 0;
            sea ​​hadFetchFailure = falso;
            sea ​​lastFetchError = null;

            const registroVerificación = entradaDepuración
                ? (debugEntry.verification = {
                    startedAt: new Date().toISOString(),
                    coincidencias de línea base: coincidencias de línea base.longitud,
                    URL de destino: URL de la hoja de cálculo de invitados
                })
                : { startedAt: new Date().toISOString(), baselineMatches: baselineMatches.length, targetUrl: guestSheetCsvUrl };

            if (!guestsSheetCsvUrl) {
                verificationLog.status = 'omitido';
                verificationLog.reason = 'sheet_url_missing';
                verificationLog.completedAt = new Date().toISOString();
                const error = new Error('reservation_sheet_url_missing');
                error.code = 'reservation_sheet_url_missing';
                lanzar error;
            }

            si (grupoAdmitido) {
                console.groupCollapsed(verificationLabel);
            }
            console.info('[Reservas] Iniciando verificación de la hoja.', {
                tabla: huella digital?.tabla,
                coincidenciasAnterior: línea baseCoincidencias.longitud
            });

            const intentoVerificación = async () => {
                intentoNumero += 1;
                registroVerificación.intentos = númeroIntento;
                console.info(`[Reservas] Intento de verificación ${attemptNumber}.`);

                intentar {
                    esperar obtenerDatosInvitados();
                } catch (error) {
                    console.warn('Error al actualizar la lista de invitados durante la verificación.', error);
                    hadFetchFailure = true;
                    últimoErrorDeObtención = error;
                    verificationLog.lastFetchError = error?.message || 'unknown_error';
                }

                const tableGuests = getGuestsForMesa(fingerprint.table);
                const coincidenciasActuales = tableGuests.filter(invitado => coincidenciasInvitadoHuellaDigital(invitado, huellaDigital));

                console.info('[Reservas] Huéspedes detectados después de actualizar:', currentMatches.length);

                if (currentMatches.length === 0) {
                    devolver falso;
                }

                if (currentMatches.length > baselineMatches.length) {
                    console.info('[Reservas] Se detectaron más partidos que al inicio.');
                    verificationLog.stage = 'inicial';
                    devuelve verdadero;
                }

                const currentCounts = buildFingerprintCountMap(currentMatches);
                for (const [key, count] of currentCounts.entries()) {
                    const baselineCount = baselineCounts.get(key) || 0;
                    si (recuento > recuentoBase) {
                        console.info('[Reservas] Se ha detectado un incremento en la huella:', key);
                        verificationLog.stage = 'incremento';
                        devuelve verdadero;
                    }
                }

                devolver falso;
            };

            intentar {
                const fecha límite = Fecha.ahora() + ENVÍO_MÁXIMO_ESPERA;

                if (await attemptVerification()) {
                    console.info('[Reservas] Verificación exitosa en el primer intento.');
                    verificationLog.status = 'success';
                    verificationLog.completedAt = new Date().toISOString();
                    devuelve verdadero;
                }

                mientras (Fecha.ahora() < fecha límite) {
                    esperar delay(SUBMISSION_POLL_INTERVAL);
                    if (await attemptVerification()) {
                        console.info('[Reservas] Verificación confirmada durante la consulta.');
                        verificationLog.status = 'success';
                        verificationLog.completedAt = new Date().toISOString();
                        verificationLog.stage = verificationLog.stage || 'cock';
                        devuelve verdadero;
                    }
                }

                console.error('[Reservations] Se agotó el tiempo de espera de la verificación sin encontrar la reserva.');
                verificationLog.completedAt = new Date().toISOString();
                if (hadFetchFailure && lastFetchError) {
                    verificationLog.status = 'advertencia';
                    verificationLog.reason = 'sheet_refresh_failed';
                    const error = new Error('reservation_sheet_refresh_failed');
                    error.code = 'reservation_sheet_refresh_failed';
                    error.causa = últimoErrorDeObtención;
                    lanzar error;
                }

                verificationLog.status = 'error';
                verificationLog.reason = 'not_found';
                const error = new Error('reserva_no_encontrada');
                error.code = 'reserva_no_encontrada';
                lanzar error;
            } finalmente {
                si (grupoAdmitido) {
                    console.groupEnd();
                }
            }
        }

        función crearClaveDeHuellaDelInvitado(invitado) {
            Si (!invitado) devolver '';
            const cédula = normalizarCadena(obtenerCédulaDeInvitado(invitado));
            const email = normalizeString(getGuestEmail(guest));
            const nombre = normalizarCadena(obtenerNombreCompletoInvitado(invitado));
            return [card, email, name].filter(Boolean).join('|');
        }

        función construirMapaDeConteoDeHuellasFilmables(invitados) {
            const counts = new Map();
            (invitados || []).forEach(invitado => {
                const clave = crearClaveDeHuellaDelInvitado(invitado) || '__en blanco__';
                counts.set(key, (counts.get(key) || 0) + 1);
            });
            recuentos de retorno;
        }

        función crearDatosFormularioDeReserva(carga útil, enviadoEn) {
            const formData = nuevo FormData();
            const safePayload = payload ?? {};
            formData.append('payload', JSON.stringify(safePayload));

            Objeto.entries(safePayload).forEach(([clave, valor]) => {
                si (valor === indefinido || valor === nulo) {
                    devolver;
                }

                if (typeof value === 'object') {
                    formData.append(key, JSON.stringify(value));
                } demás {
                    formData.append(clave, valor);
                }
            });

            formData.append('submittedAt', submittedAt);
            devolver datos del formulario;
        }

        función crearCadenaDeConsultaDeReserva(carga útil, enviadoEn) {
            const safePayload = payload ?? {};
            const params = new URLSearchParams();
            params.append('payload', JSON.stringify(safePayload));

            Objeto.entries(safePayload).forEach(([clave, valor]) => {
                si (valor === indefinido || valor === nulo) {
                    devolver;
                }

                if (typeof value === 'object') {
                    params.append(key, JSON.stringify(value));
                } demás {
                    params.append(clave, valor);
                }
            });

            params.append('submittedAt', submittedAt);
            return params.toString();
        }

        función asíncrona enviarReserva(scriptUrl, payload) {
            if (!scriptUrl) {
                lanzar nuevo Error('reservation_missing_endpoint');
            }

            const submittedAt = new Date().toISOString();
            const startedAt = Date.now();
            const debugLog = window.__reservationDebug = window.__reservationDebug || [];
            const entradaDepuración = {
                id: debugLog.length + 1,
                presentado en,
                punto final: scriptUrl,
                intentos: [],
                getAttempts: []
            };

            intentar {
                debugEntry.payload = JSON.parse(JSON.stringify(payload || {}));
            } catch (serializationError) {
                debugEntry.payload = payload;
                debugEntry.serializationError = serializationError?.message || true;
                console.warn('[Reservations] Error al serializar la carga útil para depuración.', serializationError);
            }

            debugLog.push(debugEntry);
            console.info(`[Reservas] Registro de depuración guardado (#${debugEntry.id}). Intentos totales en memoria:`, debugLog.length);
            const logGroupLabel = `[Reservas] Envío n.° ${debugEntry.id} ${submittedAt}`;
            const groupSupported = typeof console.groupCollapsed === 'function' && typeof console.groupEnd === 'function';

            si (grupoAdmitido) {
                console.groupCollapsed(logGroupLabel);
            }
            console.info('[Reservations] Endpoint configurado:', scriptUrl);
            console.info('[Reservations] Datos listos para enviar:', payload);

            const controller = typeof AbortController !== 'undefined' ? new AbortController() : null;
            const timeoutId = controlador ? setTimeout(() => controlador.abort(), SUBMISSION_MAX_WAIT) : null;
            const intentos = debugEntry.intentos;
            const getAttempts = debugEntry.getAttempts;
            sea ​​últimoModoExitoso = nulo;
            sea ​​últimoError = nulo;

            const sendRequest = async (mode) => {
                const modo normalizado = modo.aMayúsculas();
                console.info(`[Reservas] Iniciando intento ${normalizedMode}...`);

                intento constante = {
                    modo: `POST-${normalizedMode}`,
                    iniciadoEn: nuevo Date().toISOString()
                };
                intentos.push(intento);

                const opciones = {
                    método: 'POST',
                    moda,
                    cuerpo: crearFormularioDeReserva(carga útil, enviadoEn)
                };

                si (controlador) {
                    opciones.señal = controlador.señal;
                }

                if (mode === 'cors') {
                    opciones.encabezados = { 'Aceptar': 'application/json' };
                } demás {
                    opciones.mantener vivo = verdadero;
                }

                intentar {
                    const respuesta = await fetch(scriptUrl, opciones);
                    intento.completadoEn = new Date().toISOString();
                    intento.estado = respuesta?.estado ?? 'desconocido';
                    intento.ok = respuesta?.ok ?? falso;
                    intento.tipoDeRespuesta = respuesta?.tipo ?? 'n/a';

                    if (mode === 'cors') {
                        if (!response || !response.ok) {
                            const status = response ? response.status : 'unknown';
                            sea ​​responseBody = '';
                            intentar {
                                cuerpoDeRespuesta = esperar respuesta.clone().text();
                                intento.cuerpoDeRespuesta = cuerpoDeRespuesta.slice(0, 500);
                            } catch (readError) {
                                console.warn('[Reservations] No se pudo leer la respuesta de error (CORS).', readError);
                                intento.cuerpoDeRespuesta = 'no disponible';
                            }
                            intento.error = { nombre: 'HTTPError', mensaje: `HTTP ${status}` };
                            console.error(`[Reservations] HTTP response failed (${status}).`, { mode, status, responseBody });
                            lanzar nuevo Error(`reservation_http_${status}`);
                        }

                        intentar {
                            const parsed = await response.clone().json();
                            intento.respuestaJson = analizado;
                            console.info('[Reservations] CORS Response (JSON):', parsed);
                        } catch (parseError) {
                            intentar {
                                const texto = await respuesta.clone().text();
                                intento.textoRespuesta = texto.slice(0, 500);
                                console.info('[Reservas] Respuesta CORS (texto):', texto);
                            } catch (textError) {
                                console.warn('[Reservations] Failed to clone response for logging.', textError);
                            }
                        }

                        últimoModoExitoso = intento.modo;
                        devolver respuesta;
                    }

                    console.info('[Reservations] La solicitud sin CORS se envió correctamente.');
                    últimoModoExitoso = intento.modo;
                    devolver respuesta;
                } catch (error) {
                    intento.completadoEn = intento.completadoEn || new Date().toISOString();
                    intento.error = intento.error || { nombre: error?.nombre, mensaje: error?.mensaje };
                    console.error(`[Reservations] Request ${normalizedMode} failed.`, error);
                    lanzar error;
                }
            };

            const submitWithGet = async () => {
                const queryString = createReservationQueryString(payload, submittedAt);
                const separador = scriptUrl.includes('?') ? '&' : '?';
                const targetUrl = `${scriptUrl}${separator}${queryString}`;

                const intentoFetch = async (modo) => {
                    const modo normalizado = modo.aMayúsculas();
                    intento constante = {
                        modo: `GET-${normalizedMode}`,
                        URL: URL de destino,
                        iniciadoEn: nuevo Date().toISOString()
                    };
                    obtenerIntentos.push(intento);

                    const opciones = {
                        método: 'GET',
                        moda,
                        caché: 'sin almacenamiento'
                    };

                    si (controlador) {
                        opciones.señal = controlador.señal;
                    }

                    const respuesta = await fetch(targetUrl, opciones);
                    intento.completadoEn = new Date().toISOString();
                    intento.estado = respuesta?.estado ?? 'desconocido';
                    intento.ok = respuesta?.ok ?? falso;
                    intento.tipoDeRespuesta = respuesta?.tipo ?? 'n/a';

                    if (mode === 'cors') {
                        if (!response || !response.ok) {
                            const status = response ? response.status : 'unknown';
                            intento.error = { nombre: 'HTTPError', mensaje: `HTTP ${status}` };
                            lanzar nuevo Error(`reservation_http_get_${status}`);
                        }
                    }

                    últimoModoExitoso = intento.modo;
                    devolver respuesta;
                };

                intentar {
                    console.info('[Reserves] Lanzando una solicitud GET de respaldo en modo CORS.');
                    esperar intentoFetch('cors');
                } catch (error) {
                    if (error && error.name === 'AbortError') {
                        lanzar nuevo Error('reservation_timeout');
                    }

                    const mensaje = typeof error?.mensaje === 'string' ? error.mensaje : '';
                    const isHttpError = message.startsWith('reservation_http_get_');

                    if (!isHttpError && (error?.name === 'TypeError' || message.includes('Failed to fetch'))) {
                        console.warn('[Reservations] GET CORS failed, trying with no-CORS.', error);
                        esperar intentoFetch('no-cors');
                    } demás {
                        lanzar error;
                    }
                }
            };

            intentar {
                intentar {
                    esperar enviar solicitud('cors');
                } catch (error) {
                    if (error && error.name === 'AbortError') {
                        últimoError = error;
                        lanzar nuevo Error('reservation_timeout');
                    }

                    const mensaje = typeof error?.mensaje === 'string' ? error.mensaje : '';
                    const isLikelyCorsIssue = error?.name === 'TypeError' || message.includes('Failed to fetch');
                    const isHttpError = message.startsWith('reservation_http_');

                    if (message === 'reservation_http_405') {
                        console.warn('[Reservas] El punto final rechazó la solicitud POST (405). Intentando con GET.');
                        esperar a enviarConObtener();
                        devolver;
                    }

                    if (!isLikelyCorsIssue || isHttpError) {
                        últimoError = error;
                        lanzar error;
                    }

                    intentar {
                        console.warn('[Reserves] Falló el intento de CORS, intentando con POST sin CORS.');
                        esperar enviar solicitud('no-cors');
                    } catch (fallbackError) {
                        if (fallbackError && fallbackError.name === 'AbortError') {
                            últimoError = errorDeRespaldo;
                            lanzar nuevo Error('reservation_timeout');
                        }

                        const fallbackMessage = typeof fallbackError?.message === 'string' ? fallbackError.message : '';
                        if (fallbackMessage === 'reservation_http_405') {
                            console.warn('[Reserves] El punto de conexión rechazó la solicitud POST sin CORS (405). Intentando con GET.');
                            esperar a enviarConObtener();
                            devolver;
                        }
                        últimoError = errorDeRespaldo;
                        lanzar fallbackError;
                    }
                }
            } catch (error) {
                últimoError = error;
                lanzar error;
            } finalmente {
                si (timeoutId) {
                    borrarTimeout(timeoutId);
                }
                debugEntry.completedAt = new Date().toISOString();
                debugEntry.durationMs = Date.now() - startedAt;
                if (lastSuccessfulMode) {
                    debugEntry.status = 'sent';
                    debugEntry.successMode = lastSuccessfulMode;
                } demás {
                    debugEntry.status = 'error';
                    si (últimoError) {
                        debugEntry.error = { nombre: lastError.nombre, mensaje: lastError.mensaje };
                    }
                }
                si (grupoAdmitido) {
                    console.groupEnd();
                }
            }
        }

        función setSubmissionState(isSubmitting) {
            const submitButton = document.getElementById('submitReservationBtn');
            Si (!submitButton) salir;
            si (esEnviando) {
                if (!submitButton.dataset.originalLabel) {
                    submitButton.dataset.originalLabel = submitButton.textContent;
                }
                botón de envío.deshabilitado = verdadero;
                submitButton.textContent = 'Enviando...';
            } demás {
                botón de envío.deshabilitado = falso;
                if (submitButton.dataset.originalLabel) {
                    submitButton.textContent = submitButton.dataset.originalLabel;
                }
            }
        }

        función obtenerInvitadosParaMesa(etiqueta) {
            if (!label) return [];
            Si (guestsData[label]) devolver guestData[label];
            const etiqueta normalizada = normalizarCadena(etiqueta);
            const matchingKey = Object.keys(guestsData).find(key => normalizeString(key) === normalizedLabel);
            devolver claveCoincidente ? datosInvitados[claveCoincidente] : [];
        }

        función asegurarHéroeÚnico() {
            const heroSection = document.getElementById('screen1');
            Si (!heroSection) terminar;
            const heroCards = heroSection.querySelectorAll('.hero-card');
            heroCards.forEach((card, index) => {
                Si (índice === 0) retornar;
                tarjeta.eliminar();
            });
        }

        función enforceInitialScreen() {
            const contenedores = document.querySelectorAll('.container');
            contenedores.forEach((sección, índice) => {
                si (índice === 0) {
                    sección.classList.add('active');
                } demás {
                    sección.classList.remove('active');
                }
            });
            pantallaActual = 1;
        }

        función asíncrona cargarConfiguración() {
            sea ​​storedConfig = null;
            if (typeof localStorage !== 'undefined') {
                intentar {
                    almacenadoConfig = localStorage.getItem('partyConfig');
                    si (configuración almacenada) {
                        configuraciónAlmacenada = JSON.parse(configuraciónAlmacenada);
                    }
                } catch (error) {
                    console.warn('Error al leer la configuración almacenada localmente.', error);
                    storedConfig = null;
                }
            }

            si (configuración almacenada) {
                devolver configuración almacenada;
            }

            const respuesta = await fetch('config.json?_=' + Date.now());
            if (!response.ok) {
                lanzar nuevo Error('Error al cargar la configuración');
            }
            return await response.json();
        }

        función aplicarConfiguración(config) {
            Si (!config) regresar;
            asegurarHéroeÚnico();
            reservationScriptUrl = config.reservationScriptUrl
                || config.integrations?.reservationScriptUrl
                || PUNTO_FINAL_DE_RESERVA_PREDETERMINADO;
            guestSheetCsvUrl = config.guestsSheetCsvUrl
                || config.integrations?.guestSheetCsvUrl
                || URL_CSV_HOJA_DESCUENTOS_PREDETERMINADA;
            documento.título = config.siteTitle || documento.título;
            const títuloEncabezado = document.getElementById('siteTitleHeading');
            const subtitleElement = document.getElementById('siteSubtitle');
            const descripciónElement = document.getElementById('siteDescription');
            const heroImage = document.getElementById('heroImage');

            if (titleHeading) titleHeading.textContent = config.siteTitle || 'Fiesta Social';
            if (subtitleElement) subtitleElement.textContent = config.siteSubtitle || 'Registro de invitados';
            if (descriptionElement) descriptionElement.textContent = config.siteDescription || '';
            if (heroImage && config.heroImage) heroImage.src = config.heroImage;

            if (Array.isArray(config.tables)) {
                config.mesas.sort((a, b) => (a.number || 0) - (b.number || 0));
            }

            if (!Array.isArray(config.zones) || config.zones.length === 0) {
                config.zones = DEFAULT_ZONES.map(zone => ({
                    id: zone.id,
                    etiqueta: etiqueta de zona,
                    nombre de clase: zona.nombre de clase,
                    posición: { ...zona.posición }
                }));
            }

            renderZones(config.zones);
            renderTables(config.tables || []);
            actualizarResumen(config.tables || []);
        }

        función actualizarResumen(tablas) {
            const totalMesasCounter = document.getElementById('totalMesasCounter');
            const contadorTotalCapacidad = document.getElementById('contadorTotalCapacidad');

            if (totalMesasCounter) totalMesasCounter.textContent = mesas.length;
            si (capacidadTotalCounter) {
                const capacidadTotal = mesas.reduce((acc, mesa) => acc + (mesa.capacity ?? siteConfig?.defaultCapacity ?? 0), 0);
                capacidadTotalCounter.textContent = capacidad total;
            }
        }

        función renderZones(zonas) {
            const salónMap = document.getElementById('salonMap');
            Si (!salonMap) regresar;

            salonMap.querySelectorAll('.map-zone').forEach(zoneElement => zoneElement.remove());

            const sourceZones = Array.isArray(zones) && zones.length ? zones : DEFAULT_ZONES;

            sourceZones.forEach(zone => {
                const zoneElement = document.createElement('div');
                zoneElement.className = ['map-zone', zone.className || ''].filter(Boolean).join(' ').trim();
                zonaElement.textContent = zona.label || '';
                ZoneElement.dataset.zoneId = zona.id || '';

                const posX = parseFloat(zone.position?.x);
                const posY = parseFloat(zone.position?.y);
                const safeX = Number.isNaN(posX) ? 0 : Math.min(Math.max(posX, 0), 100);
                const safeY = Número.isNaN(posY)? 0: Matemáticas.min(Math.max(posY, 0), 100);
                zoneElement.style.setProperty('--zone-x', safeX);
                zoneElement.style.setProperty('--zone-y', safeY);

                salonMap.appendChild(zoneElement);
            });
        }

        función renderTables(tables) {
            const salónMap = document.getElementById('salonMap');
            Si (!salonMap) regresar;
            salonMap.querySelectorAll('.table').forEach(table => table.remove());

            tablas.paraCada(tabla => {
                const tableElement = document.createElement('button');
                tableElement.type = 'botón';
                tableElement.className = 'table';
                tableElement.id = `table${table.number}`;
                const etiqueta = tabla.etiqueta || `Tabla ${tabla.número}`;
                mesaElement.dataset.label = etiqueta;
                mesaElement.dataset.capacity = mesa.capacity ?? siteConfig?.defaultCapacity ?? 0;
                tableElement.style.left = `${table.position?.x ?? 0}%`;
                tableElement.style.top = `${table.position?.y ?? 0}%`;
                tableElement.textContent = table.number ?? label;
                mesaElement.setAttribute('aria-label', `${label} (capacidad ${mesaElement.dataset.capacity})`);
                tableElement.addEventListener('click', () => selectTable(table));
                mesaElement.addEventListener('mouseover', event => showGuests(label, event));
                mesaElement.addEventListener('focus', event => showGuests(label, event));
                tableElement.addEventListener('mouseleave', hideGuests);
                tableElement.addEventListener('blur', hideGuests);
                salonMap.appendChild(tableElement);
            });

            actualizarTablesCompleteColor();
        }

        función startDataFetchInterval() {
            detenerIntervaloDeObtenciónDeDatos();
            dateFetchInterval = setInterval(() => {
                obtenerDatosInvitados().catch(error => {
                    console.warn('Error al actualizar la lista de invitados en segundo plano.', error);
                });
            }, 5000);
        }

        función detenerIntervaloDeObtenciónDeDatos() {
            clearInterval(dataFetchInterval);
        }

        función siguientePantalla(númeroSiguientePantalla) {
            si (nextScreenNumber === undefined) {
                si (pantallaActual === 2) {
                    let invalidFields = validateForm('guestForm');
                    if (invalidFields.length > 0) {
                        alert('Por favor, complete correctamente los siguientes campos:\n- ' + invalidFields.join('\n- '));
                        devolver;
                    }
                    sea ​​compañero = document.getElementById('compañero').value;
                    si (compañero === 'sí') {
                        let quantity Companions = document.getElementById('quantity Companions').value;
                        if (!quantityofaccompanies) {
                            alert('Por favor, seleccione el número de acompañantes.');
                            devolver;
                        }
                        generarFormularioAcompañantes(montoAcompañantes);
                        número de pantalla siguiente = 3;
                    } demás {
                        número de pantalla siguiente = 4;
                    }
                } else if (currentScreen === 3) {
                    let invalidFields = validateForm('companantesForm');
                    if (invalidFields.length > 0) {
                        alert('Por favor, complete correctamente los siguientes campos complementarios:\n- ' + invalidFields.join('\n- '));
                        devolver;
                    }
                    número de pantalla siguiente = 4;
                } demás {
                    númeroDePantallaSiguiente = pantallaActual + 1;
                }
            }
            document.getElementById(`screen${currentScreen}`).classList.remove('active');
            pantallaActual = númeroDePantallaSiguiente;
            document.getElementById(`screen${currentScreen}`).classList.add('active');

            si (pantallaActual === 4) {
                obtenerDatosInvitados().catch(error => {
                    console.warn('No se pudo actualizar la lista de invitados al cargar el resumen.', error);
                });
                iniciarIntervaloDeObtenciónDeDatos();
            } demás {
                detenerIntervaloDeObtenciónDeDatos();
            }
        }

        función validarFormulario(formularioId) {
            let form = document.getElementById(formId);
            if (!form) return [];
            sea ​​invalidFields = [];
            let elements = form.querySelectorAll('input, select');
            elementos.forEach(function(elemento) {
                if (!element.checkValidity()) {
                    let label = form.querySelector(`label[for="${element.id}"]`);
                    let fieldName = label ? label.textContent.replace(':', '') : element.name || element.id;
                    camposInválidos.push(nombreCampo.trim());
                }
            });
            Devuelve campos no válidos;
        }

        función prevScreen(pantalla) {
            if (currentScreen === 4 && document.getElementById('companion').value === 'no') {
                pantalla = 2;
            }
            document.getElementById(`screen${currentScreen}`).classList.remove('active');
            pantallaActual = pantalla;
            document.getElementById(`screen${currentScreen}`).classList.add('active');
            detenerIntervaloDeObtenciónDeDatos();
        }

        función alternarCompañero() {
            sea ​​compañero = document.getElementById('compañero').value;
            let cantidadAcompañantes = document.getElementById('cantidadAcompañantes');
            let companionQuantityContainer = document.getElementById('companionQuantity');
            si (compañero === 'sí') {
                companionQuantityContainer.style.display = 'block';
                companionQuantityContainer.style.opacity = '1';
                companionQuantity.setAttribute('required', 'required');
            } demás {
                companionQuantityContainer.style.opacity = '0';
                companionQuantityContainer.style.display = 'none';
                companionQuantity.removeAttribute('required');
                companionQuantity.value = '';
            }
        }

        función generarFormularioAcompañantes(cantidad) {
            let accompanantesForm = document.getElementById('companantesForm');
            compañerosForm.innerHTML = '';
            para (sea i = 1; i <= cantidad; i++) {
                companionsForm.innerHTML += `
                    <div class="form-grid">
                        <div class="form-field">
                            <h3>Compañero ${i}</h3>
                            <label for="accompanying name${i}">Nombre</label>
                            <input type="text" id="nombre del acompañante${i}" name="nombre del acompañante${i}" required>
                        </div>
                        <div class="form-field">
                            <label for="menuAccompaniante${i}">Menú</label>
                            <select id="menuAcompanante${i}" name="menuAcompanante${i}" required>
                                <option value="" selected>Seleccionar</option>
                                <option value="normal">Normal</option>
                                <option value="vegetarian">Vegetariano</option>
                                <option value="vegan">Vegano</option>
                                <option value="celiac">Celiaco</option>
                            </select>
                        </div>
                    </div>`;
            }
        }

        función seleccionarTabla(configuraciónTabla) {
            Si (!tableConfig) devolver;
            const etiqueta = mesaConfig.label || `Tabla ${tableConfig.number}`;
            const tableInput = document.getElementById('table');
            tableInput.value = etiqueta;

            document.querySelectorAll('.table').forEach(table => table.classList.remove('selected'));
            const tableElement = document.getElementById(`table${tableConfig.number}`);
            si (elemento de tabla) {
                tableElement.classList.add('selected');
            }

            const summaryLabel = document.getElementById('tableSelectedLabel');
            si (etiqueta de resumen) {
                resumenLabel.textContent = etiqueta;
            }

            const tableContainer = document.querySelector('.table-container');
            si (contenedor de tabla) {
                tableContainer.style.display = 'block';
            }

            actualizarTextoTabla();
        }

        función actualizarTextoTabla() {
            const tableInput = document.getElementById('table');
            const tableText = document.getElementById('tableText');
            const mesaSeleccionada = mesaInput.value;
            si (textoTabla && tablaSeleccionada) {
                tableText.textContent = selectedTable;
            }
            actualizarAsientos();
            actualizarListaDeInvitados();
        }

        función actualizarAsientos() {
            const tableInput = document.getElementById('table');
            const mesaSeleccionada = mesaInput.value;
            const seatsContainer = document.getElementById('seatsContainer');
            Si (!contenedorDeAsientos) devolver;

            sea ​​maxCapacity = getMesaCapacity(selectedMesa);
            asientosContainer.innerHTML = '';

            para (sea i = 1; i <= capacidadMáxima; i++) {
                let seat = document.createElement('div');
                asiento.classList.add('asiento');
                asiento.conjuntodedatos.asiento = i;
                asientosContenedor.agregarHijo(asiento);
            }

            const asientos = document.querySelectorAll('.seat');
            constante centroX = 50;
            constante centroY = 50;
            radio constante = 38;

            asientos.paraCada((asiento, índice) => {
                ángulo constante = (índice / asientos.longitud) * (2 * Math.PI);
                constante x = centroX + radio * Math.cos(ángulo);
                constante y = centroY + radio * Math.sin(ángulo);
                asiento.estilo.posición = 'absoluta';
                asiento.estilo.izquierda = `${x}%`;
                asiento.estilo.superior = `${y}%`;
                asiento.estilo.transformar = 'translate(-50%, -50%)';
            });

            const tableGuests = obtenerGuestsForMesa(mesaSeleccionada);
            if (selectedTable && tableGuests.length) {
                Sea totalInvitados = 0;
                tableGuests.forEach(guest => {
                    const asientosNecesarios = contarAsientosParaInvitados(invitado);
                    for (let i = 0; i < seatsNeeded; i++) {
                        Si (total de invitados < capacidad máxima) {
                            const asiento = document.querySelector(`.seat[data-seat="${totalGuests + 1}"]`);
                            si (asiento) {
                                asiento.classList.add('ocupado');
                            }
                            totalInvitados++;
                        }
                    }
                });
            }
        }

        función actualizarListaDeInvitados() {
            const tableInput = document.getElementById('table');
            const mesaSeleccionada = mesaInput.value;
            const listaInvitados = document.getElementById('listaInvitados');
            Si (!listaDeInvitados) terminar;

            guestList.innerHTML = '';

            const invitados = obtenerInvitadosParaMesa(mesaseleccionada);
            if (selectedTable && guests.length) {

                invitados.paraCada(invitado => {
                    const fullname = getGuestFullName(guest) || 'Nombre no disponible';
                    guestList.innerHTML += `<div><strong>${fullname}</strong></div>`;

                    extraerNombresCompañeros(invitado).paraCada(nombre => {
                        guestList.innerHTML += `<div>${nombre}</div>`;
                    });
                });
            } demás {
                guestList.innerHTML = 'No hay huéspedes registrados en esta mesa.';
            }
        }

        función asíncrona submitForm() {
            const tableInput = document.getElementById('table');
            const mesaSeleccionada = mesaInput.value;

            sea ​​maxCapacity = getMesaCapacity(selectedMesa);

            Sea totalInvitados = 0;
            const tableGuests = obtenerGuestsForMesa(mesaSeleccionada);
            const baselineGuests = Array.isArray(mesaGuests) ? tableGuests.slice() : [];
            if (selectedTable && tableGuests.length) {
                tableGuests.forEach(guest => {
                    totalInvitados += contarAsientosInvitados(invitado);
                });
            }

            const cantidad Compañeros = document.getElementById('cantidad Compañeros').value || 0;
            const companionsCount = parseInt(cantidad de Compañeros, 10) || 0;
            const totalNuevosInvitados = 1 + conteoCompañeros;

            if (!selectedMesa || (totalGuests + totalNewGuests) > maxCapacity) {
                alert('Debe seleccionar una tabla disponible antes de continuar o la tabla no tiene suficiente espacio.');
                devolver;
            }

            let guestForm = document.getElementById('guestForm');
            let accompanantesForm = document.getElementById('companantesForm');

            if (!(guestForm.checkValidity() && companionsForm.checkValidity())) {
                alert('Por favor, complete todos los campos obligatorios.');
                devolver;
            }

            const formData = nuevo FormData(guestForm);
            const datos acompañantes = new FormData(formulario acompañante);
            const compañeros = [];

            companionsData.forEach((value, key) => {
                if (key.includes('accompanying name')) {
                    const índice = parseInt(key.replace(/\D/g, '')) - 1;
                    if (!companions[index]) companions[index] = {};
                    compañeros[índice].nombre = valor;
                } else if (key.includes('Menú de acompañamiento')) {
                    const índice = parseInt(key.replace(/\D/g, '')) - 1;
                    if (!companions[index]) companions[index] = {};
                    compañeros[índice].menú = valor;
                }
            });

            const fecha = {
                correo: formData.get('mail'),
                calificación: formData.get('calificación'),
                scalaphone: formData.get('scalaphone'),
                nombre: formData.get('nombre'),
                apellido: formData.get('apellido'),
                tarjeta: formData.get('tarjeta'),
                compañero: formData.get('compañero'),
                cantidad de acompañante: formData.get('cantidad de acompañante'),
                menú: formData.get('menu'),
                compañeros: compañeros,
                tabla: formData.get('tabla')
            };

            const huella digital = crearHuellaDeReserva(fecha);

            if (!reservationScriptUrl) {
                alert('No se encontró la dirección del servicio de reservas. Compruebe la configuración.');
                devolver;
            }

            establecerEstadoDeEnvío(verdadero);

            intentar {
                esperar a enviarReserva(urlScriptReserva, fecha);
                const debugEntries = window.__reservationDebug || [];
                const debugEntries = debugEntries.length ? debugEntries[debugEntries.length - 1] : null;
                sea ​​verificationWarning = null;
                sea ​​verificationDetails = null;

                intentar {
                    esperar confirmarReservaPersistente(huella digital, huéspedesBase, entradaDepuración);
                } catch (verificationError) {
                    const verificationMessage = typeof verificationError?.message === 'string' ? verificationError.message : '';
                    if (verificationMessage === 'reservation_sheet_url_missing' || verificationMessage === 'reservation_sheet_refresh_failed') {
                        advertencia de verificación = mensaje de verificación;
                        verificationDetails = verificationError?.cause?.message || verificationError?.message || null;
                        console.warn('Se ha enviado la reserva, pero ha fallado la verificación.', verificationError);
                    } demás {
                        lanzar error de verificación;
                    }
                }

                mostrarConfirmación();

                if (verificationWarning === 'reservation_sheet_url_missing') {
                    alert('Su reserva se ha enviado, pero no hemos podido verificarla porque falta la URL pública de la hoja de huéspedes. Pídale al administrador que publique la hoja como CSV y que actualice la URL en el panel de administración.');
                } else if (verificationWarning === 'reservation_sheet_refresh_failed') {
                    const extra = verificationDetails ? ` Detalle: ${verificationDetails}` : '';
                    alert('Su reserva ha sido enviada, pero no pudimos leer la hoja de huéspedes para confirmarla. Compruebe que la hoja esté publicada como CSV y que el enlace en Administración sea accesible.' + extra);
                }
            } catch (error) {
                console.error('Error al registrar la reserva:', error);
                const mensaje = typeof error?.mensaje === 'string' ? error.mensaje : '';
                if (message === 'reserva_no_encontrada') {
                    alert('No pudimos confirmar su reserva en la hoja de cálculo. Por favor, revise su conexión o confirme con el administrador que el enlace de Google Apps Script está activo.');
                } else if (message === 'reservation_timeout') {
                    alert('El servicio de reservas tardó demasiado en responder. Por favor, inténtelo de nuevo en unos instantes.');
                } else if (message === 'reservation_missing_endpoint') {
                    alert('La dirección del servicio de reservas no está configurada. Consulte la sección Administración.');
                } else if (message.startsWith('reservation_http_get_') || message.startsWith('reservation_http_')) {
                    const partes = mensaje.split('_');
                    const statusCode = parts[parts.length - 1] || 'unknown';
                    if (statusCode === '405') {
                        alert('El servicio de Google Apps Script respondió con el código 405 (Método no permitido). Asegúrese de publicar una versión que incluya doPost(e) y que la aplicación web permita el acceso a "Cualquier persona con el enlace".');
                    } else if (statusCode === '404') {
                        alert('El servicio de Google Apps Script respondió con el código 404. Verifique que haya pegado la URL correcta de la implementación activa en el panel de administración.');
                    } demás {
                        alert(`El servicio de Google Apps Script devolvió el código ${statusCode}. Consulta los registros del script para obtener más detalles.`);
                    }
                } demás {
                    alert('Hubo un problema al enviar la reserva. Por favor, inténtelo de nuevo y, si el problema persiste, póngase en contacto con el administrador.');
                }
            } finalmente {
                establecerEstadoDeEnvío(falso);
            }
        }

        función mostrarConfirmación() {
            const mesaConfirmada = document.getElementById('mesa').value;
            document.getElementById('mesaConfirmada').textContent = mesaConfirmada;
            const current = document.getElementById(`screen${currentScreen}`);
            if (current) current.classList.remove('active');
            const modal = document.getElementById('confirmationModal');
            si (modal) {
                modal.classList.add('active');
                modal.style.display = 'flex';
            }
            detenerIntervaloDeObtenciónDeDatos();
        }

        función finalizarRegistro() {
            ubicación.recargar();
        }

        función asíncrona obtenerDatosInvitados() {
            if (!guestsSheetCsvUrl) {
                const error = new Error('sheet_url_missing');
                error.code = 'sheet_url_missing';
                lanzar error;
            }
            intentar {
                const respuesta = await fetch(appendCacheBuster(guestsSheetCsvUrl), { cache: 'no-store' });
                if (!response.ok) {
                    lanzar nuevo Error(`sheet_fetch_${response.status}`);
                }

                const csv = await response.text();
                const datos = csvToJSON(csv);
                invitadosFecha = fecha;
                actualizarTablesCompleteColor();
                actualizarListaDeInvitados();
                actualizarAsientos();
                fecha de regreso;
            } catch (error) {
                console.error('Error al obtener los datos del invitado:', error);
                lanzar error;
            }
        }

        función parseCSVLine(line) {
            const resultado = [];
            sea ​​actual = '';
            sea ​​insideQuotes = falso;

            for (let i = 0; i < line.length; i++) {
                const char = línea[i];
                si (carácter === '"') {
                    if (insideQuotes && line[i + 1] === '"') {
                        actual += '';
                        i++;
                    } demás {
                        insideQuotes = !insideQuotes;
                    }
                } else if (char === ',' && !insideQuotes) {
                    resultado.push(actual);
                    actual = '';
                } demás {
                    actual += carácter;
                }
            }
            resultado.push(actual);

            devolver resultado;
        }

        función csvToJSON(csv) {
            if (!csv) return {};
            const sanitized = csv.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            const líneas = sanitized.split('\n').filter(línea => línea.trim() !== '');
            if (lines.length === 0) return {};

            const encabezados = parseCSVLine(líneas[0]);
            const encabezados normalizados = encabezados.map(encabezado => encabezado.trim());
            const clavesEncabezadoNormales = encabezadosNormales.map(cadenaNormales);

            const resultado = {};

            for (let i = 1; i < lines.length; i++) {
                const valores ​​= parseCSVLine(líneas[i]);
                if (values.every(value => value === undefined || value === null || value.trim() === '')) continue;

                entrada constante = {};
                normalizedHeaders.forEach((header, index) => {
                    entrada[encabezado] = (valores[índice] ?? '').trim();
                });

                const tableIndex = normalizedHeaderKeys.indexOf('table');
                sea ​​tableLabel = '';
                si (tableIndex !== -1) {
                    tableLabel = (valores[tableIndex] ?? '').trim();
                }
                if (!tableLabel) {
                    const tableKey = Object.keys(entry).find(key => normalizeString(key) === 'table');
                    si (clave de tabla) {
                        etiquetaTabla = entrada[claveTabla];
                    }
                }

                Si (!tableLabel) continuar;

                if (!result[tableLabel]) {
                    resultado[etiqueta de tabla] = [];
                }
                resultado[mesaLabel].push(entry);
            }

            devolver resultado;
        }

        función actualizarMesasCompletaColor() {
            document.querySelectorAll('.table').forEach(table => table.classList.remove('complete'));

            Objeto.keys(guestsData).forEach(mesaLabel => {
                const invitados = datosInvitados[etiquetaTabla];
                Sea totalInvitados = 0;

                sea ​​maxCapacity = getMesaCapacity(mesaLabel);

                invitados.paraCada(invitado => {
                    totalInvitados += contarAsientosInvitados(invitado);
                });

                Si (totalHuéspedes >= capacidadMáxima) {
                    const mesaConfig = siteConfig?.mesas?.find(m => (m.label || `Mesa ${m.number}`) === mesaLabel);
                    sea ​​tableId = null;
                    si (tableConfig) {
                        tableId = `table${tableConfig.number}`;
                    } else if (mesaLabel.startsWith('Mesa ')) {
                        const númeroTabla = tableLabel.split(' ')[1];
                        idTabla = `tabla${númeroTabla}`;
                    }
                    si (tableId) {
                        const tableElement = document.getElementById(tableId);
                        si (elemento de tabla) {
                            tableElement.classList.add('complete');
                        }
                    }
                }
            });
        }

        función obtenerCapacitanciaMesa(etiquetaMesa) {
            if (!siteConfig || !Array.isArray(siteConfig.mesas)) {
                devolver siteConfig?.defaultCapacity || 10;
            }
            const mesaConfig = siteConfig.mesas.find(mesa => {
                const etiqueta = tabla.etiqueta || `Tabla ${tabla.número}`;
                Si (etiqueta === mesaLabel) devolver verdadero;
                if (mesaLabel.startsWith('Mesa ')) {
                    return `Tabla ${table.number}` === tableLabel;
                }
                devolver falso;
            });
            if (mesaConfig && typeof mesaConfig.capacity === 'number') {
                Devuelve tableConfig.capacity;
            }
            devolver siteConfig.defaultCapacity || 10;
        }

        función mostrarInvitados(mesa, evento) {
            const tooltip = document.getElementById('tooltip');
            Si (!tooltip) salir;
            let content = 'No hay huéspedes registrados en esta mesa.';
            const tableGuests = obtenerGuestsForMesa(table);
            if (gueststable.length) {
                const guestNames = mesaGuests.map(guest => {
                    sea ​​nombreCompleto = obtenerNombreCompletoInvitado(invitado);
                    const compañeros = extraerNombresCompañeros(invitado);
                    if (companions.length > 0) {
                        nombreCompleto += ` (+${companions.join(', ')})`;
                    }
                    devolver nombre completo || 'Invitado';
                }).unirse(', ');
                contenido = nombresDeInvitados || feliz
            }
            tooltip.textContent = contenido;
            tooltip.style.display = 'block';

            sea ​​x = evento?.pageX;
            sea ​​y = evento?.pageY;
            const objetivo = evento?.objetivoActual || evento?.objetivo;
            si ((!x || !y) && objetivo) {
                const rect = target.getBoundingClientRect();
                x = rect.left + window.scrollX + rect.width / 2;
                y = rect.top + window.scrollY + rect.height / 2;
            }
            tooltip.style.left = `${x}px`;
            tooltip.style.top = `${y}px`;
        }

        función ocultarInvitados() {
            const tooltip = document.getElementById('tooltip');
            Si (!tooltip) salir;
            tooltip.style.display = 'ninguno';
        }

        document.addEventListener('DOMContentLoaded', async () => {
            aplicarPantallaInicial();
            asegurarHéroeÚnico();
            intentar {
                siteConfig = esperar cargarConfig();
                aplicarConfig(siteConfig);
            } catch (error) {
                console.error('Error al inicializar la configuración', error);
                const subtitleElement = document.getElementById('siteSubtitle');
                si (elemento de subtítulo) {
                    subtitleElement.textContent = 'Error al cargar la configuración. Revise el archivo config.json.';
                }
            }
        });
    </script>
</body>
</html>
